/*
 * fis
 * http://fis.baidu.com/
 */

'use strict';

// 缓存构造器
// 如：var cache = fis.cache(conf, 'conf');
var Cache = Object.derive(function(path, dir){
    var file = fis.util.realpath(path);
    // 如果path不是一个文件，则报错“不能缓存此文件”。
    if(!fis.util.isFile(file)){
        fis.log.error('unable to cache file[' + path + ']: No such file.');
    }
    // 获取文件stat信息
    this.timestamp = fis.util.mtime(file).getTime();
    this.deps = {}; // 此缓存依赖
    this.version = fis.version; // fis版本信息

    // 获取此文件路径信息
    var info = fis.util.pathinfo(file);
    var basename = fis.project.getCachePath(dir, info.basename);
    var hash = fis.util.md5(file, 10); // 生成基于文件file的10位hash值
    this.cacheFile = basename + '-c-' + hash + '.tmp'; // 缓存文件file内容
    this.cacheInfo = basename + '-o-' + hash + '.json'; // 缓存文件file的stat信息
}, {
    // 写入缓存
    save : function(content, info){
        var infos = {
            version : this.version,
            timestamp : this.timestamp,
            deps : this.deps,
            info : info
        };
        fis.util.write(this.cacheInfo, JSON.stringify(infos));
        fis.util.write(this.cacheFile, content);
    },
    // 判断缓存是否过期
    revert : function(file){
        fis.log.debug('revert cache'); // 恢复缓存
        if(
            exports.enable // 可以恢复缓存
            && fis.util.exists(this.cacheInfo) // cacheFile文件是否存在
            && fis.util.exists(this.cacheFile) // cacheInfo文件是否存在
        ){
            fis.log.debug('cache file exists');
            var infos = fis.util.readJSON(this.cacheInfo); // 读取cacheInfo信息
            fis.log.debug('cache info read');
            // 对比cacheInfo信息，判断文件是否发生变化。
            if(infos.version == this.version && infos.timestamp == this.timestamp){
                var deps = infos['deps'];
                for(var f in deps){
                    if(deps.hasOwnProperty(f)){
                        var d = fis.util.mtime(f);
                        // 判断文件的依赖文件是否缓存过期（是否有改动）
                        if(d == 0 || deps[f] != d.getTime()){
                            fis.log.debug('cache is expired');
                            return false;
                        }
                    }
                }
                this.deps = deps;
                fis.log.debug('cache is valid');
                if(file){
                    file.info = infos.info;
                    file.content = fis.util.fs.readFileSync(this.cacheFile);
                }
                fis.log.debug('revert cache finished');
                return true;
            }
        }
        fis.log.debug('cache is expired'); // cache过期
        return false;
    },
    // 增加文件依赖
    addDeps : function(file){
        var path = fis.util.realpath(file);
        if(path){
            this.deps[path] = fis.util.mtime(path).getTime();
        } else {
            fis.log.warning('unable to add dependency file[' + file + ']: No such file.');
        }
        return this;
    },
    // 移除文件依赖
    removeDeps : function(file){
        var path = fis.util.realpath(file);
        if(path && this.deps[path]){
            delete this.deps[path];
        }
        return this;
    },
    // merge缓存依赖
    mergeDeps : function(cache){
        var deps = {};
        if(cache instanceof Cache){
            deps = cache.deps
        } else if(typeof cache === 'object'){
            deps = cache
        } else {
            fis.log.error('unable to merge deps of data[' + cache + ']');
        }
        fis.util.map(deps, this.deps, true);
    }
});

// 根据Cache创建构造器并作为接口factory返回
exports = module.exports = Cache.factory();
// 设置接口factory静态属性enable
exports.enable = true;
// 设置接口factory静态方法Cache
exports.Cache = Cache;
// 设置接口factory静态方法clean
// 清理缓存目录
exports.clean = function(name){
    name = name || '';
    var path = fis.project.getCachePath(name); // 获取缓存目录name的路径
    if(fis.util.exists(path)){ // 如果存在此缓存目录，则删除之。
        fis.util.del(path);
    }
};