<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @ignore
 * custom event mechanism for kissy.
 * refer: http://www.w3.org/TR/domcore/#interface-customevent
 * @author yiminghe@gmail.com
 */
KISSY.add('event/custom/observable', function (S, CustomEventObserver, CustomEventObject, BaseEvent) {
    var Utils = BaseEvent.Utils;
    var undefined = undefined;

<span id='KISSY-Event-CustomEvent-CustomEventObservable'>    /**
</span>     * custom event for registering and un-registering observer for specified event on normal object.
     * @class KISSY.Event.CustomEvent.CustomEventObservable
     * @extends KISSY.Event.Observable
     * @private
     */
    function CustomEventObservable() {
        var self = this;
        CustomEventObservable.superclass.constructor.apply(self, arguments);
        self.defaultFn = null;
        self.defaultTargetOnly = false;

<span id='KISSY-Event-CustomEvent-CustomEventObservable-cfg-bubbles'>        /**
</span>         * whether this event can bubble.
         * Defaults to: true
         * @cfg {Boolean} bubbles
         */
        self.bubbles = true;
<span id='KISSY-Event-CustomEvent-CustomEventObservable-cfg-currentTarget'>        /**
</span>         * event target which binds current custom event
         * @cfg {KISSY.Event.CustomEvent.Target} currentTarget
         */
    }

    S.extend(CustomEventObservable, BaseEvent.Observable, {
<span id='KISSY-Event-CustomEvent-CustomEventObservable-method-on'>        /**
</span>         * add a observer to custom event's observers
         * @param {Object} cfg {@link KISSY.Event.CustomEvent.Observer} 's config
         */
        on: function (cfg) {
<span id='global-property-'>            var observer = /**@ignore
</span>             @type KISSY.Event.CustomEvent.Observer*/new CustomEventObserver(cfg);
            if (S.Config.debug) {
                if (!observer.fn) {
                    S.error('lack event handler for ' + this.type);
                }
            }
            if (this.findObserver(observer) == -1) {
                this.observers.push(observer);
            }
        },

<span id='KISSY-Event-CustomEvent-CustomEventObservable-method-fire'>        /**
</span>         * notify current custom event 's observers and then bubble up if this event can bubble.
         * @param {KISSY.Event.CustomEvent.Object} eventData
         * @return {*} return false if one of custom event 's observers (include bubbled) else
         * return last value of custom event 's observers (include bubbled) 's return value.
         */
        fire: function (eventData) {
            eventData = eventData || {};

            var self = this,
                bubbles = self.bubbles,
                currentTarget = self.currentTarget,
                parents,
                parentsLen,
                type = self.type,
                defaultFn = self.defaultFn,
                i,
                customEventObject = eventData,
                gRet, ret;

            eventData.type = type;

            if (!(customEventObject instanceof  CustomEventObject)) {
                customEventObject.target = currentTarget;
                customEventObject = new CustomEventObject(customEventObject);
            }

            customEventObject.currentTarget = currentTarget;

            ret = self.notify(customEventObject);

            if (gRet !== false &amp;&amp; ret != undefined) {
                gRet = ret;
            }

            // gRet === false prevent
            if (bubbles &amp;&amp; !customEventObject.isPropagationStopped()) {

                parents = currentTarget.getTargets();

                parentsLen = parents &amp;&amp; parents.length || 0;

                for (i = 0; i &lt; parentsLen &amp;&amp; !customEventObject.isPropagationStopped(); i++) {

                    ret = parents[i].fire(type, customEventObject);

                    // false 优先返回
                    if (gRet !== false &amp;&amp; ret !== undefined) {
                        gRet = ret;
                    }

                }
            }

            // bubble first
            // parent defaultFn first
            // child defaultFn last
            if (defaultFn &amp;&amp; !customEventObject.isDefaultPrevented()) {
                var target=customEventObject.target,
                    lowestCustomEventObservable = target.getCustomEventObservable(customEventObject.type);
                if ((!self.defaultTargetOnly &amp;&amp; !lowestCustomEventObservable.defaultTargetOnly) ||
                    currentTarget == target) {
                    // default value as final value if possible
                    gRet = defaultFn.call(currentTarget, customEventObject);
                }
            }

            return gRet;

        },

<span id='KISSY-Event-CustomEvent-CustomEventObservable-method-notify'>        /**
</span>         * notify current event 's observers
         * @param {KISSY.Event.CustomEvent.Object} event
         * @return {*} return false if one of custom event 's observers  else
         * return last value of custom event 's observers 's return value.
         */
        notify: function (event) {
            // duplicate,in case detach itself in one observer
            var observers = [].concat(this.observers),
                ret,
                gRet,
                len = observers.length,
                i;

            for (i = 0; i &lt; len &amp;&amp; !event.isImmediatePropagationStopped(); i++) {
                ret = observers[i].notify(event, this);
                if (gRet !== false &amp;&amp; ret !== undefined) {
                    gRet = ret;
                }
            }

            return gRet;
        },

<span id='KISSY-Event-CustomEvent-CustomEventObservable-method-detach'>        /**
</span>         * remove some observers from current event 's observers by observer config param
         * @param {Object} cfg {@link KISSY.Event.CustomEvent.Observer} 's config
         */
        detach: function (cfg) {
            var groupsRe,
                self = this,
                fn = cfg.fn,
                context = cfg.context,
                currentTarget = self.currentTarget,
                observers = self.observers,
                groups = cfg.groups;

            if (!observers.length) {
                return;
            }

            if (groups) {
                groupsRe = Utils.getGroupsRe(groups);
            }

            var i, j, t, observer, observerContext, len = observers.length;

            // 移除 fn
            if (fn || groupsRe) {
                context = context || currentTarget;

                for (i = 0, j = 0, t = []; i &lt; len; ++i) {
                    observer = observers[i];
                    observerContext = observer.context || currentTarget;
                    if (
                        (context != observerContext) ||
                            // 指定了函数，函数不相等，保留
                            (fn &amp;&amp; fn != observer.fn) ||
                            // 指定了删除的某些组，而该 observer 不属于这些组，保留，否则删除
                            (groupsRe &amp;&amp; !observer.groups.match(groupsRe))
                        ) {
                        t[j++] = observer;
                    }
                }

                self.observers = t;
            } else {
                // 全部删除
                self.reset();
            }

            // does not need to clear memory if customEvent has no observer
            // customEvent has defaultFn .....!
            // self.checkMemory();
        }
    });

    return CustomEventObservable;
}, {
    requires: [ './observer', './object', 'event/base']
});
<span id='global-property-'>/**
</span> * @ignore
 * 2012-10-26 yiminghe@gmail.com
 *  - custom event can bubble by default!
 */</pre>
</body>
</html>
