<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @ignore
 * Use style to gen element and wrap range's elements.Modified from CKEditor.
 * @author yiminghe@gmail.com
 */
/*
 Copyright (c) 2003-2010, CKSource - Frederico Knabben. All rights reserved.
 For licensing, see LICENSE.html or http://ckeditor.com/license
 */
KISSY.add(&quot;editor/styles&quot;, function (S, Editor) {
    var TRUE = true,
        FALSE = false,
        NULL = null,
        $ = S.all,
        Dom = S.DOM,
        KER = Editor.RangeType,
        KESelection = Editor.Selection,
        KEP = Editor.PositionType,
        KERange = Editor.Range,
        KEST,
    //Walker = Editor.Walker,
        Node = S.Node,
        UA = S.UA,
        ElementPath = Editor.ElementPath,
        blockElements = {
            &quot;address&quot;: 1,
            &quot;div&quot;: 1,
            &quot;h1&quot;: 1,
            &quot;h2&quot;: 1,
            &quot;h3&quot;: 1,
            &quot;h4&quot;: 1,
            &quot;h5&quot;: 1,
            &quot;h6&quot;: 1,
            &quot;p&quot;: 1,
            &quot;pre&quot;: 1
        },
        DTD = Editor.XHTML_DTD,
        objectElements = {
            //why? a should be same to inline? 但是不能互相嵌套
            //a:1,
            &quot;embed&quot;: 1,
            &quot;hr&quot;: 1,
            &quot;img&quot;: 1,
            &quot;li&quot;: 1,
            &quot;object&quot;: 1,
            &quot;ol&quot;: 1,
            &quot;table&quot;: 1,
            &quot;td&quot;: 1,
            &quot;tr&quot;: 1,
            &quot;th&quot;: 1,
            &quot;ul&quot;: 1,
            &quot;dl&quot;: 1,
            &quot;dt&quot;: 1,
            &quot;dd&quot;: 1,
            &quot;form&quot;: 1
        },
        semicolonFixRegex = /\s*(?:;\s*|$)/g,
        varRegex = /#\((.+?)\)/g;

<span id='KISSY-Editor-StyleType'>    /**
</span>     * enum for style type
     * @enum {number} KISSY.Editor.StyleType
     */
    Editor.StyleType = KEST ={
<span id='KISSY-Editor-StyleType-property-STYLE_BLOCK'>        /**
</span>         * block type
         */
        STYLE_BLOCK: 1,
<span id='KISSY-Editor-StyleType-property-STYLE_INLINE'>        /**
</span>         * inline type
         */
        STYLE_INLINE: 2,
<span id='KISSY-Editor-StyleType-property-STYLE_OBJECT'>        /**
</span>         * object type
         */
        STYLE_OBJECT: 3
    };

    function notBookmark(node) {
        //only get attributes on element nodes by kissy
        //when textnode attr() return undefined ,wonderful !!!
        return !Dom.attr(node, &quot;_ke_bookmark&quot;);
    }

    function replaceVariables(list, variablesValues) {
        for (var item in list) {
            if (typeof (list[ item ]) == 'string') {
                list[ item ] = list[ item ].replace(varRegex, function (match, varName) {
                    return variablesValues[ varName ];
                });
            } else {
                replaceVariables(list[ item ], variablesValues);
            }
        }
    }

<span id='KISSY-Editor-Style'>    /**
</span>     * style manipulation class
     * @class KISSY.Editor.Style
     * @param styleDefinition {Object} style definition
     * @param [variablesValues] {Object} style variables
     */
    function KEStyle(styleDefinition, variablesValues) {
        if (variablesValues) {
            styleDefinition = S.clone(styleDefinition);
            replaceVariables(styleDefinition, variablesValues);
        }

        var element = this[&quot;element&quot;] = this.element = ( styleDefinition[&quot;element&quot;] || '*' ).toLowerCase();

        this[&quot;type&quot;] = this.type = ( element == '#text' || blockElements[ element ] ) ?
            KEST.STYLE_BLOCK
            : objectElements[ element ] ?
            KEST.STYLE_OBJECT : KEST.STYLE_INLINE;

        this._ = {
            &quot;definition&quot;: styleDefinition
        };
    }

    function applyStyle(document, remove) {
        // Get all ranges from the selection.
        var self = this,
            func = remove ? self.removeFromRange : self.applyToRange;
        // Apply the style to the ranges.
        //ie select 选中期间document得不到range
        document.body.focus();

        var selection = new KESelection(document);
        // Bookmark the range so we can re-select it after processing.
        var ranges = selection.getRanges();
        for (var i = 0; i &lt; ranges.length; i++) {
            //格式化后，range进入格式标签内
            func.call(self, ranges[ i ]);
        }
        selection.selectRanges(ranges);
    }

    KEStyle.prototype = {
        constructor: KEStyle,

        apply: function (document) {
            applyStyle.call(this, document, FALSE);
        },

        remove: function (document) {
            applyStyle.call(this, document, TRUE);
        },

        applyToRange: function (range) {
            var self = this;
            return ( self.applyToRange =
                this.type == KEST.STYLE_INLINE ?
                    applyInlineStyle
                    : self.type == KEST.STYLE_BLOCK ?
                    applyBlockStyle
                    : self.type == KEST.STYLE_OBJECT ?
                    NULL
                    //yiminghe note:no need!
                    //applyObjectStyle
                    : NULL ).call(self, range);
        },

        removeFromRange: function (range) {
            var self = this;
            return ( self.removeFromRange =
                self.type == KEST.STYLE_INLINE ?
                    removeInlineStyle
                    : NULL ).call(self, range);
        },

        // Checks if an element, or any of its attributes, is removable by the
        // current style definition.
        checkElementRemovable: function (element, fullMatch) {
            if (!element)
                return FALSE;

            var def = this._.definition,
                attribs, styles;

            // If the element name is the same as the style name.
            if (element.nodeName() == this.element) {
                // If no attributes are defined in the element.
                if (!fullMatch &amp;&amp; !element._4e_hasAttributes())
                    return TRUE;

                attribs = getAttributesForComparison(def);

                if (attribs[&quot;_length&quot;]) {
                    for (var attName in attribs) {

                        if (attName == '_length')
                            continue;

                        var elementAttr = element.attr(attName) || '';
                        if (attName == 'style' ?
                            compareCssText(attribs[ attName ],
                                normalizeCssText(elementAttr, FALSE))
                            : attribs[ attName ] == elementAttr) {
                            if (!fullMatch)
                                return TRUE;
                        }
                        else if (fullMatch)
                            return FALSE;

                    }
                    if (fullMatch)
                        return TRUE;
                }
                else
                    return TRUE;
            }

            // Check if the element can be somehow overriden.
            var overrides = getOverrides(this),
                override = overrides[ element.nodeName() ] || overrides[&quot;*&quot;];

            if (override) {
                // If no attributes have been defined, remove the element.
                if (!( attribs = override.attributes )
                    &amp;&amp; !( styles = override.styles)
                    )
                    return TRUE;
                if (attribs) {
                    for (var i = 0; i &lt; attribs.length; i++) {
                        attName = attribs[i][0];
                        var actualAttrValue = element.attr(attName);
                        if (actualAttrValue) {
                            var attValue = attribs[i][1];
                            // Remove the attribute if:
                            //    - The override definition value is NULL;
                            //    - The override definition value is a string that
                            //      matches the attribute value exactly.
                            //    - The override definition value is a regex that
                            //      has matches in the attribute value.
                            if (attValue === NULL ||
                                ( typeof attValue == 'string'
                                    &amp;&amp; actualAttrValue == attValue ) ||
                                attValue.test &amp;&amp; attValue.test(actualAttrValue))
                                return TRUE;
                        }
                    }
                }
                if (styles) {
                    for (i = 0; i &lt; styles.length; i++) {
                        var styleName = styles[i][0];
                        var actualStyleValue = element.css(styleName);
                        if (actualStyleValue) {
                            var styleValue = styles[i][1];
                            if (styleValue === NULL
                                //inherit wildcard !
                                //|| styleValue == &quot;inherit&quot;
                                || ( typeof styleValue == 'string'
                                &amp;&amp; actualStyleValue == styleValue ) ||
                                styleValue.test &amp;&amp; styleValue.test(actualStyleValue))
                                return TRUE;
                        }
                    }
                }
            }
            return FALSE;
        },

<span id='KISSY-Editor-Style-method-checkActive'>        /**
</span>         * Get the style state inside an element path. Returns &quot;TRUE&quot; if the
         * element is active in the path.
         */
        checkActive: function (elementPath) {
            switch (this.type) {
                case KEST.STYLE_BLOCK :
                    return this.checkElementRemovable(elementPath.block
                        || elementPath.blockLimit, TRUE);

                case KEST.STYLE_OBJECT :
                case KEST.STYLE_INLINE :

                    var elements = elementPath.elements;

                    for (var i = 0, element; i &lt; elements.length; i++) {
                        element = elements[ i ];

                        if (this.type == KEST.STYLE_INLINE
                            &amp;&amp; ( Dom.equals(element, elementPath.block)
                            || Dom.equals(element, elementPath.blockLimit) ))
                            continue;

                        if (this.type == KEST.STYLE_OBJECT
                            &amp;&amp; !( element.nodeName() in objectElements ))
                            continue;

                        if (this.checkElementRemovable(element, TRUE))
                            return TRUE;
                    }
            }
            return FALSE;
        }

    };

    KEStyle.getStyleText = function (styleDefinition) {
        // If we have already computed it, just return it.
        var stylesDef = styleDefinition._ST;
        if (stylesDef)
            return stylesDef;

        stylesDef = styleDefinition[&quot;styles&quot;];

        // Builds the StyleText.
        var stylesText = ( styleDefinition[&quot;attributes&quot;]
                &amp;&amp; styleDefinition[&quot;attributes&quot;][ 'style' ] ) || '',
            specialStylesText = '';

        if (stylesText.length)
            stylesText = stylesText.replace(semicolonFixRegex, ';');

        for (var style in stylesDef) {

            var styleVal = stylesDef[ style ],
                text = ( style + ':' + styleVal ).replace(semicolonFixRegex, ';');

            // Some browsers don't support 'inherit' property value, leave them intact. (#5242)
            if (styleVal == 'inherit')
                specialStylesText += text;
            else
                stylesText += text;

        }

        // Browsers make some changes to the style when applying them. So, here
        // we normalize it to the browser format.
        if (stylesText.length)
            stylesText = normalizeCssText(stylesText);

        stylesText += specialStylesText;

        // Return it, saving it to the next request.
        return ( styleDefinition._ST = stylesText );
    };

    function getElement(style, targetDocument, element) {
        var el,
        //def = style._.definition,
            elementName = style[&quot;element&quot;];

        // The &quot;*&quot; element name will always be a span for this function.
        if (elementName == '*')
            elementName = 'span';

        // Create the element.
        el = new Node(targetDocument.createElement(elementName));

        // #6226: attributes should be copied before the new ones are applied
        if (element)
            element._4e_copyAttributes(el);

        return setupElement(el, style);
    }

    function setupElement(el, style) {
        var def = style._[&quot;definition&quot;],
            attributes = def[&quot;attributes&quot;],
            styles = KEStyle.getStyleText(def);

        // Assign all defined attributes.
        if (attributes) {
            for (var att in attributes) {
                el.attr(att, attributes[ att ]);
            }
        }

        // Assign all defined styles.

        if (styles)
            el[0].style.cssText = styles;

        return el;
    }

    function applyBlockStyle(range) {
        // Serializible bookmarks is needed here since
        // elements may be merged.
        var bookmark = range.createBookmark(TRUE),
            iterator = range.createIterator();
        iterator.enforceRealBlocks = TRUE;

        // make recognize &lt;br /&gt; tag as a separator in ENTER_BR mode (#5121)
        //if (this._.enterMode)
        iterator.enlargeBr = TRUE;

        var block, doc = range.document;
        // Only one =
        while (( block = iterator.getNextParagraph() )) {
            var newBlock = getElement(this, doc, block);
            replaceBlock(block, newBlock);
        }
        range.moveToBookmark(bookmark);
    }

    // Wrapper function of String::replace without considering of head/tail bookmarks nodes.
    function replace(str, regexp, replacement) {
        var headBookmark = '',
            tailBookmark = '';

        str = str.replace(/(^&lt;span[^&gt;]+_ke_bookmark.*?\/span&gt;)|(&lt;span[^&gt;]+_ke_bookmark.*?\/span&gt;$)/gi,
            function (str, m1, m2) {
                m1 &amp;&amp; ( headBookmark = m1 );
                m2 &amp;&amp; ( tailBookmark = m2 );
                return '';
            });
        return headBookmark + str.replace(regexp, replacement) + tailBookmark;
    }

<span id='KISSY-Editor-Style-method-toPre'>    /**
</span>     * Converting from a non-PRE block to a PRE block in formatting operations.
     */
    function toPre(block, newBlock) {
        // First trim the block content.
        var preHTML = block.html();

        // 1. Trim head/tail spaces, they're not visible.
        preHTML = replace(preHTML, /(?:^[ \t\n\r]+)|(?:[ \t\n\r]+$)/g, '');
        // 2. Delete ANSI whitespaces immediately before and after &lt;BR&gt; because
        //    they are not visible.
        preHTML = preHTML.replace(/[ \t\r\n]*(&lt;br[^&gt;]*&gt;)[ \t\r\n]*/gi, '$1');
        // 3. Compress other ANSI whitespaces since they're only visible as one
        //    single space previously.
        // 4. Convert &amp;nbsp; to spaces since &amp;nbsp; is no longer needed in &lt;PRE&gt;.
        preHTML = preHTML.replace(/([ \t\n\r]+|&amp;nbsp;)/g, ' ');
        // 5. Convert any &lt;BR /&gt; to \n. This must not be done earlier because
        //    the \n would then get compressed.
        preHTML = preHTML.replace(/&lt;br\b[^&gt;]*&gt;/gi, '\n');

        // Krugle: IE normalizes innerHTML to &lt;pre&gt;, breaking whitespaces.
        if (UA['ie']) {
            var temp = block[0].ownerDocument.createElement('div');
            temp.appendChild(newBlock[0]);
            newBlock.outerHtml('&lt;pre&gt;' + preHTML + '&lt;/pre&gt;');
            newBlock = new Node(temp.firstChild);
            newBlock._4e_remove();
        }
        else
            newBlock.html(preHTML);

        return newBlock;
    }


    // Split into multiple &lt;pre&gt; blocks separated by double line-break.
    function splitIntoPres(preBlock) {
        // Exclude the ones at header OR at tail,
        // and ignore bookmark content between them.
        var duoBrRegex = /(\S\s*)\n(?:\s|(&lt;span[^&gt;]+_ck_bookmark.*?\/span&gt;))*\n(?!$)/gi,
        //blockName = preBlock.nodeName(),
            splittedHTML = replace(preBlock.outerHtml(),
                duoBrRegex,
                function (match, charBefore, bookmark) {
                    return charBefore + '&lt;/pre&gt;' + bookmark + '&lt;pre&gt;';
                });

        var pres = [];
        splittedHTML.replace(/&lt;pre\b.*?&gt;([\s\S]*?)&lt;\/pre&gt;/gi,
            function (match, preContent) {
                pres.push(preContent);
            });
        return pres;
    }

    // Replace the original block with new one, with special treatment
    // for &lt;pre&gt; blocks to make sure content format is well preserved, and merging/splitting adjacent
    // when necessary.(#3188)
    function replaceBlock(block, newBlock) {
        var newBlockIsPre = newBlock.nodeName == ('pre'),
            blockIsPre = block.nodeName == ('pre'),
            isToPre = newBlockIsPre &amp;&amp; !blockIsPre,
            isFromPre = !newBlockIsPre &amp;&amp; blockIsPre;

        if (isToPre)
            newBlock = toPre(block, newBlock);
        else if (isFromPre)
        // Split big &lt;pre&gt; into pieces before start to convert.
            newBlock = fromPres(splitIntoPres(block), newBlock);
        else
            block._4e_moveChildren(newBlock);

        block[0].parentNode.replaceChild(newBlock[0], block[0]);
        if (newBlockIsPre) {
            // Merge previous &lt;pre&gt; blocks.
            mergePre(newBlock);
        }
    }

   // Merge a &lt;pre&gt; block with a previous sibling if available.
    function mergePre(preBlock) {
        var previousBlock;
        if (!( ( previousBlock = preBlock._4e_previousSourceNode(TRUE, Dom.NodeType.ELEMENT_NODE) )
            &amp;&amp; previousBlock.nodeName() == 'pre' ))
            return;

        // Merge the previous &lt;pre&gt; block contents into the current &lt;pre&gt;
        // block.
        //
        // Another thing to be careful here is that currentBlock might contain
        // a '\n' at the beginning, and previousBlock might contain a '\n'
        // towards the end. These new lines are not normally displayed but they
        // become visible after merging.
        var mergedHTML = replace(previousBlock.html(), /\n$/, '') + '\n\n' +
            replace(preBlock.html(), /^\n/, '');

        // Krugle: IE normalizes innerHTML from &lt;pre&gt;, breaking whitespaces.
        if (UA['ie'])
            preBlock.outerHtml('&lt;pre&gt;' + mergedHTML + '&lt;/pre&gt;');
        else
            preBlock.html(mergedHTML);

        previousBlock._4e_remove();
    }


  // Converting a list of &lt;pre&gt; into blocks with format well preserved.
    function fromPres(preHTMLs, newBlock) {
        var docFrag = newBlock[0].ownerDocument.createDocumentFragment();
        for (var i = 0; i &lt; preHTMLs.length; i++) {
            var blockHTML = preHTMLs[ i ];

            // 1. Trim the first and last line-breaks immediately after and before &lt;pre&gt;,
            // they're not visible.
            blockHTML = blockHTML.replace(/(\r\n|\r)/g, '\n');
            blockHTML = replace(blockHTML, /^[ \t]*\n/, '');
            blockHTML = replace(blockHTML, /\n$/, '');
            // 2. Convert spaces or tabs at the beginning or at the end to &amp;nbsp;
            blockHTML = replace(blockHTML, /^[ \t]+|[ \t]+$/g, function (match, offset) {
                if (match.length == 1)    // one space, preserve it
                    return '&amp;nbsp;';
                else if (!offset)        // beginning of block
                    return new Array(match.length).join('&amp;nbsp;') + ' ';
                else                // end of block
                    return ' ' + new Array(match.length).join('&amp;nbsp;');
            });

            // 3. Convert \n to &lt;BR&gt;.
            // 4. Convert contiguous (i.e. non-singular) spaces or tabs to &amp;nbsp;
            blockHTML = blockHTML.replace(/\n/g, '&lt;br&gt;');
            blockHTML = blockHTML.replace(/[ \t]{2,}/g,
                function (match) {
                    return new Array(match.length).join('&amp;nbsp;') + ' ';
                });

            var newBlockClone = newBlock.clone();
            newBlockClone.html(blockHTML);
            docFrag.appendChild(newBlockClone[0]);
        }
        return docFrag;
    }

    function applyInlineStyle(range) {
        var self = this,
            document = range.document;

        if (range.collapsed) {
            // Create the element to be inserted in the Dom.
            var collapsedElement = getElement(this, document, undefined);
            // Insert the empty element into the Dom at the range position.
            range.insertNode(collapsedElement);
            // Place the selection right inside the empty element.
            range.moveToPosition(collapsedElement, KER.POSITION_BEFORE_END);
            return;
        }
        var elementName = this[&quot;element&quot;],
            def = this._[&quot;definition&quot;],
            isUnknownElement,
        // Get the DTD definition for the element. Defaults to &quot;span&quot;.
            dtd = DTD[ elementName ];
        if (!dtd) {
            isUnknownElement = TRUE;
            dtd = DTD[&quot;span&quot;];
        }

        // Bookmark the range so we can re-select it after processing.
        var bookmark = range.createBookmark();

        // Expand the range.
        range.enlarge(KER.ENLARGE_ELEMENT);
        range.trim();

        // Get the first node to be processed and the last, which concludes the
        // processing.
        var boundaryNodes = range.createBookmark(),
            firstNode = boundaryNodes.startNode,
            lastNode = boundaryNodes.endNode,
            currentNode = firstNode,
            styleRange;

        while (currentNode &amp;&amp; currentNode[0]) {
            var applyStyle = FALSE;

            if (Dom.equals(currentNode, lastNode)) {
                currentNode = NULL;
                applyStyle = TRUE;
            }
            else {
                var nodeType = currentNode[0].nodeType,
                    nodeName = nodeType == Dom.NodeType.ELEMENT_NODE ?
                        currentNode.nodeName() : NULL;

                if (nodeName &amp;&amp; currentNode.attr('_ke_bookmark')) {
                    currentNode = currentNode._4e_nextSourceNode(TRUE);
                    continue;
                }

                // Check if the current node can be a child of the style element.
                if (!nodeName || (
                    dtd[ nodeName ] &amp;&amp;
                        ( currentNode._4e_position(lastNode) |
                            ( KEP.POSITION_PRECEDING |
                                KEP.POSITION_IDENTICAL |
                                KEP.POSITION_IS_CONTAINED) )
                            == ( KEP.POSITION_PRECEDING +
                            KEP.POSITION_IDENTICAL +
                            KEP.POSITION_IS_CONTAINED ) &amp;&amp;
                        ( !def[&quot;childRule&quot;] || def[&quot;childRule&quot;](currentNode) )
                    )) {
                    var currentParent = currentNode.parent();


                    // hack for
                    // 1&lt;a href='http://www.taobao.com'&gt;2&lt;/a&gt;3
                    // select all ,set link to http://www.ckeditor.com
                    // expect =&gt; &lt;a href='http://www.ckeditor.com'&gt;123&lt;/a&gt; (same with tinymce)
                    // but now =&gt; &lt;a href=&quot;http://www.ckeditor.com&quot;&gt;1&lt;/a&gt;
                    // &lt;a href=&quot;http://www.taobao.com&quot;&gt;2&lt;/a&gt;
                    // &lt;a href=&quot;http://www.ckeditor.com&quot;&gt;3&lt;/a&gt;
                    // http://dev.ckeditor.com/ticket/8470
                    if (currentParent &amp;&amp;
                        elementName == &quot;a&quot; &amp;&amp;
                        currentParent.nodeName() == elementName) {
                        var tmpANode = getElement(self, document, undefined);
                        currentParent._4e_moveChildren(tmpANode);
                        currentParent[0].parentNode.replaceChild(tmpANode[0], currentParent[0]);
                        tmpANode._4e_mergeSiblings();
                    }

                    // Check if the style element can be a child of the current
                    // node parent or if the element is not defined in the DTD.
                    else if (currentParent &amp;&amp; currentParent[0]
                        &amp;&amp; ( ( DTD[currentParent.nodeName()] ||
                        DTD[&quot;span&quot;] )[ elementName ] ||
                        isUnknownElement )
                        &amp;&amp; ( !def[&quot;parentRule&quot;] || def[&quot;parentRule&quot;](currentParent) )) {
                        // This node will be part of our range, so if it has not
                        // been started, place its start right before the node.
                        // In the case of an element node, it will be included
                        // only if it is entirely inside the range.
                        if (!styleRange &amp;&amp;
                            ( !nodeName
                                || !DTD.$removeEmpty[ nodeName ]
                                || ( currentNode._4e_position(lastNode) |
                                ( KEP.POSITION_PRECEDING |
                                    KEP.POSITION_IDENTICAL |
                                    KEP.POSITION_IS_CONTAINED ))
                                ==
                                ( KEP.POSITION_PRECEDING +
                                    KEP.POSITION_IDENTICAL +
                                    KEP.POSITION_IS_CONTAINED )
                                )) {
                            styleRange = new KERange(document);
                            styleRange.setStartBefore(currentNode);
                        }

                        // Non element nodes, or empty elements can be added
                        // completely to the range.
                        if (nodeType == Dom.NodeType.TEXT_NODE ||
                            ( nodeType == Dom.NodeType.ELEMENT_NODE &amp;&amp; !currentNode[0].childNodes.length )) {
                            var includedNode = currentNode,
                                parentNode = null;

                            // This node is about to be included completelly, but,
                            // if this is the last node in its parent, we must also
                            // check if the parent itself can be added completelly
                            // to the range.
                            //2010-11-18 fix ; http://dev.ckeditor.com/ticket/6687
                            //&lt;span&gt;&lt;book/&gt;123&lt;book/&gt;&lt;/span&gt; 直接越过末尾 &lt;book/&gt;

                            // If the included node still is the last node in its
                            // parent, it means that the parent can't be included
                            // in this style DTD, so apply the style immediately.
                            while (
                                (applyStyle = !includedNode.next(notBookmark, 1))
                                    &amp;&amp; ( (parentNode = includedNode.parent()) &amp;&amp;
                                    dtd[ parentNode.nodeName() ] )
                                    &amp;&amp; ( parentNode._4e_position(firstNode) |
                                    KEP.POSITION_FOLLOWING |
                                    KEP.POSITION_IDENTICAL |
                                    KEP.POSITION_IS_CONTAINED) ==
                                    ( KEP.POSITION_FOLLOWING +
                                        KEP.POSITION_IDENTICAL +
                                        KEP.POSITION_IS_CONTAINED )
                                    &amp;&amp; ( !def[&quot;childRule&quot;] || def[&quot;childRule&quot;](parentNode) )) {
                                includedNode = parentNode;
                            }

                            styleRange.setEndAfter(includedNode);

                        }
                    }
                    else
                        applyStyle = TRUE;
                }
                else
                    applyStyle = TRUE;

                // Get the next node to be processed.
                currentNode = currentNode._4e_nextSourceNode();
            }

            // Apply the style if we have something to which apply it.
            if (applyStyle &amp;&amp; styleRange &amp;&amp; !styleRange.collapsed) {
                // Build the style element, based on the style object definition.
                var styleNode = getElement(self, document, undefined),

                // Get the element that holds the entire range.
                    parent = styleRange.getCommonAncestor();


                var removeList = {
                    styles: {},
                    attrs: {},
                    // Styles cannot be removed.
                    blockedStyles: {},
                    // Attrs cannot be removed.
                    blockedAttrs: {}
                };

                var attName, styleName = null, value;

                // Loop through the parents, removing the redundant attributes
                // from the element to be applied.
                while (styleNode &amp;&amp; parent &amp;&amp; styleNode[0] &amp;&amp; parent[0]) {
                    if (parent.nodeName() == elementName) {
                        for (attName in def.attributes) {

                            if (removeList.blockedAttrs[ attName ]
                                || !( value = parent.attr(styleName) ))
                                continue;

                            if (styleNode.attr(attName) == value) {
                                //removeList.attrs[ attName ] = 1;
                                styleNode.removeAttr(attName);
                            } else
                                removeList.blockedAttrs[ attName ] = 1;

                        }
                        //bug notice add by yiminghe@gmail.com
                        //&lt;span style=&quot;font-size:70px&quot;&gt;&lt;span style=&quot;font-size:30px&quot;&gt;^xxx$&lt;/span&gt;&lt;/span&gt;
                        //下一次格式xxx为70px
                        //var exit = FALSE;
                        for (styleName in def.styles) {

                            if (removeList.blockedStyles[ styleName ]
                                || !( value = parent.style(styleName) ))
                                continue;

                            if (styleNode.style(styleName) == value) {
                                //removeList.styles[ styleName ] = 1;
                                styleNode.style(styleName, &quot;&quot;);
                            } else
                                removeList.blockedStyles[ styleName ] = 1;

                        }

                        if (!styleNode._4e_hasAttributes()) {
                            styleNode = NULL;
                            break;
                        }
                    }

                    parent = parent.parent();
                }

                if (styleNode) {
                    // Move the contents of the range to the style element.
                    styleNode[0].appendChild(styleRange.extractContents());

                    // Here we do some cleanup, removing all duplicated
                    // elements from the style element.
                    removeFromInsideElement(self, styleNode);

                    // Insert it into the range position (it is collapsed after
                    // extractContents.
                    styleRange.insertNode(styleNode);

                    // Let's merge our new style with its neighbors, if possible.
                    styleNode._4e_mergeSiblings();

                    // As the style system breaks text nodes constantly, let's normalize
                    // things for performance.
                    // With IE, some paragraphs get broken when calling normalize()
                    // repeatedly. Also, for IE, we must normalize body, not documentElement.
                    // IE is also known for having a &quot;crash effect&quot; with normalize().
                    // We should try to normalize with IE too in some way, somewhere.
                    if (!UA['ie'])
                        styleNode[0].normalize();
                }
                // Style already inherit from parents, left just to clear up any internal overrides. (#5931)
                /*
                 from koubei
                 1.输入ab
                 2.ctrl-a 设置字体大小 x
                 3.选中b设置字体大小 y
                 4.保持选中b,设置字体大小 x
                 expect: b 大小为 x
                 actual: b 大小为 y
                 */
                else {
                    styleNode = new Node(document.createElement(&quot;span&quot;));
                    styleNode[0].appendChild(styleRange.extractContents());
                    styleRange.insertNode(styleNode);
                    removeFromInsideElement(self, styleNode);
                    styleNode._4e_remove(true);
                }

                // Style applied, let's release the range, so it gets
                // re-initialization in the next loop.
                styleRange = NULL;
            }
        }

        firstNode._4e_remove();
        lastNode._4e_remove();
        range.moveToBookmark(bookmark);
        // Minimize the result range to exclude empty text nodes. (#5374)
        range.shrink(KER.SHRINK_TEXT);

    }

    function removeInlineStyle(range) {
        /*
          Make sure our range has included all &quot;collapsed&quot; parent inline nodes so
          that our operation logic can be simpler.
         */
        range.enlarge(KER.ENLARGE_ELEMENT);

        var bookmark = range.createBookmark(),
            startNode = bookmark.startNode;

        if (range.collapsed) {

            var startPath = new ElementPath(startNode.parent()),
            // The topmost element in elements path which we should jump out of.
                boundaryElement;


            for (var i = 0, element; i &lt; startPath.elements.length
                &amp;&amp; ( element = startPath.elements[i] ); i++) {
                /*
                  1. If it's collapsed inside text nodes, try to remove the style from the whole element.

                  2. Otherwise if it's collapsed on element boundaries, moving the selection
                   outside the styles instead of removing the whole tag,
                   also make sure other inner styles were well preserved.(#3309)
                 */
                if (element == startPath.block ||
                    element == startPath.blockLimit) {
                    break;
                }
                if (this.checkElementRemovable(element)) {
                    var endOfElement = range.checkBoundaryOfElement(element, KER.END),
                        startOfElement = !endOfElement &amp;&amp;
                            range.checkBoundaryOfElement(element, KER.START);
                    if (startOfElement || endOfElement) {
                        boundaryElement = element;
                        boundaryElement.match = startOfElement ? 'start' : 'end';
                    } else {
                        /*
                          Before removing the style node, there may be a sibling to the style node
                          that's exactly the same to the one to be removed. To the user, it makes
                          no difference that they're separate entities in the Dom tree. So, merge
                          them before removal.
                         */
                        element._4e_mergeSiblings();
                        //yiminghe:note,bug for ckeditor
                        //qc #3700 for chengyu(yiminghe)
                        //从word复制过来的已编辑文本无法使用粗体和斜体等功能取消
                        if (element.nodeName() != this.element) {
                            var _overrides = getOverrides(this);
                            removeOverrides(element,
                                _overrides[ element.nodeName() ] || _overrides[&quot;*&quot;]);
                        } else {
                            removeFromElement(this, element);
                        }

                    }
                }
            }

            // Re-create the style tree after/before the boundary element,
            // the replication start from bookmark start node to define the
            // new range.
            if (boundaryElement) {
                var clonedElement = startNode;
                for (i = 0; ; i++) {
                    var newElement = startPath.elements[ i ];
                    if (newElement.equals(boundaryElement))
                        break;
                    // Avoid copying any matched element.
                    else if (newElement.match)
                        continue;
                    else
                        newElement = newElement.clone();
                    newElement[0].appendChild(clonedElement[0]);
                    clonedElement = newElement;
                }
                //脱离当前的元素，将 bookmark 插入到当前元素后面
                // &lt;strong&gt;xx|&lt;/strong&gt;  -&gt;
                // &lt;strong&gt;xx&lt;strong&gt;|
                clonedElement[ boundaryElement.match == 'start' ? 'insertBefore' :
                    'insertAfter' ](boundaryElement);
                // &lt;strong&gt;|&lt;/strong&gt; -&gt;
                // &lt;strong&gt;&lt;/strong&gt;|
                var tmp = boundaryElement.html();
                if (!tmp ||
                    // filling char
                    tmp == '\u200b') {
                    boundaryElement.remove();
                }
                // http://code.google.com/p/chromium/issues/detail?id=149894
                else if (UA.webkit) {
                    $(range.document.createTextNode('\u200b')).insertBefore(clonedElement);
                }
            }
        } else {
            /*
             * Now our range isn't collapsed. Lets walk from the start node to the end
             * node via DFS and remove the styles one-by-one.
             */
            var endNode = bookmark.endNode,
                me = this;

            /*
             * Find out the style ancestor that needs to be broken down at startNode
             * and endNode.
             */
            function breakNodes() {
                var startPath = new ElementPath(startNode.parent()),
                    endPath = new ElementPath(endNode.parent()),
                    breakStart = NULL,
                    breakEnd = NULL;
                for (var i = 0; i &lt; startPath.elements.length; i++) {
                    var element = startPath.elements[ i ];

                    if (element == startPath.block ||
                        element == startPath.blockLimit)
                        break;

                    if (me.checkElementRemovable(element))
                        breakStart = element;
                }
                for (i = 0; i &lt; endPath.elements.length; i++) {
                    element = endPath.elements[ i ];

                    if (element == endPath.block ||
                        element == endPath.blockLimit)
                        break;

                    if (me.checkElementRemovable(element))
                        breakEnd = element;
                }

                if (breakEnd)
                    endNode._4e_breakParent(breakEnd);
                if (breakStart)
                    startNode._4e_breakParent(breakStart);
            }

            breakNodes();

            // Now, do the DFS walk.
            var currentNode = new Node(startNode[0].nextSibling);
            while (currentNode[0] !== endNode[0]) {
                /*
                 * Need to get the next node first because removeFromElement() can remove
                 * the current node from Dom tree.
                 */
                var nextNode = currentNode._4e_nextSourceNode();
                if (currentNode[0] &amp;&amp;
                    currentNode[0].nodeType == Dom.NodeType.ELEMENT_NODE &amp;&amp;
                    this.checkElementRemovable(currentNode)) {
                    // Remove style from element or overriding element.
                    if (currentNode.nodeName() == this[&quot;element&quot;])
                        removeFromElement(this, currentNode);
                    else {
                        var overrides = getOverrides(this);
                        removeOverrides(currentNode,
                            overrides[ currentNode.nodeName() ] || overrides[&quot;*&quot;]);

                    }

                    /*
                     * removeFromElement() may have merged the next node with something before
                     * the startNode via mergeSiblings(). In that case, the nextNode would
                     * contain startNode and we'll have to call breakNodes() again and also
                     * reassign the nextNode to something after startNode.
                     */
                    if (nextNode[0].nodeType == Dom.NodeType.ELEMENT_NODE &amp;&amp;
                        nextNode.contains(startNode)) {
                        breakNodes();
                        nextNode = new Node(startNode[0].nextSibling);
                    }
                }
                currentNode = nextNode;
            }
        }
        range.moveToBookmark(bookmark);
    }

    // Turn inline style text properties into one hash.
    function parseStyleText(styleText) {
        styleText = String(styleText);
        var retval = {};
        styleText.replace(/&amp;quot;/g, '&quot;')
            .replace(/\s*([^ :;]+)\s*:\s*([^;]+)\s*(?=;|$)/g,
            function (match, name, value) {
                retval[ name ] = value;
            });
        return retval;
    }

    function compareCssText(source, target) {
        typeof source == 'string' &amp;&amp; ( source = parseStyleText(source) );
        typeof target == 'string' &amp;&amp; ( target = parseStyleText(target) );
        for (var name in source) {

            // Value 'inherit'  is treated as a wildcard,
            // which will match any value.
            if (!( name in target &amp;&amp;
                ( target[ name ] == source[ name ]
                    || source[ name ] == 'inherit'
                    || target[ name ] == 'inherit' ) )) {
                return FALSE;
            }

        }
        return TRUE;
    }

    function normalizeCssText(unparsedCssText, nativeNormalize) {
        var styleText = &quot;&quot;;
        if (nativeNormalize !== FALSE) {
            // Injects the style in a temporary span object, so the browser parses it,
            // retrieving its final format.
            var temp = document.createElement('span');
            temp.style.cssText = unparsedCssText;
            //temp.setAttribute('style', unparsedCssText);
            styleText = temp.style.cssText || '';
        }
        else
            styleText = unparsedCssText;

        // Shrinking white-spaces around colon and semi-colon (#4147).
        // Compensate tail semi-colon.
        return styleText.replace(/\s*([;:])\s*/, '$1')
            .replace(/([^\s;])$/, &quot;$1;&quot;)
            .replace(/,\s+/g, ',')// Trimming spaces after comma (e.g. font-family name)(#4107).
            .toLowerCase();
    }

    /*
     把 styles(css配置) 作为 属性 style 统一看待
     注意对 inherit 的处理
     */
    function getAttributesForComparison(styleDefinition) {
        // If we have already computed it, just return it.
        var attribs = styleDefinition._AC;
        if (attribs) {
            return attribs;
        }
        attribs = {};

        var length = 0,

        // Loop through all defined attributes.
            styleAttribs = styleDefinition[&quot;attributes&quot;];
        if (styleAttribs) {
            for (var styleAtt in styleAttribs) {

                length++;
                attribs[ styleAtt ] = styleAttribs[ styleAtt ];

            }
        }

        // Includes the style definitions.
        var styleText = KEStyle.getStyleText(styleDefinition);
        if (styleText) {
            if (!attribs[ 'style' ])
                length++;
            attribs[ 'style' ] = styleText;
        }

        // Appends the &quot;length&quot; information to the object.
        //防止被compiler优化
        attribs[&quot;_length&quot;] = length;

        // Return it, saving it to the next request.
        return ( styleDefinition._AC = attribs );
    }


<span id='KISSY-Editor-Style-method-getOverrides'>    /**
</span>      Get the the collection used to compare the elements and attributes,
      defined in this style overrides, with other element. All information in
      it is lowercased.
     */
    function getOverrides(style) {
        if (style._.overrides)
            return style._.overrides;

        var overrides = ( style._.overrides = {} ),
            definition = style._.definition[&quot;overrides&quot;];

        if (definition) {
            // The override description can be a string, object or array.
            // Internally, well handle arrays only, so transform it if needed.
            if (!S.isArray(definition))
                definition = [ definition ];

            // Loop through all override definitions.
            for (var i = 0; i &lt; definition.length; i++) {
                var override = definition[i];
                var elementName;
                var overrideEl;
                var attrs, styles;

                // If can be a string with the element name.
                if (typeof override == 'string')
                    elementName = override.toLowerCase();
                // Or an object.
                else {
                    elementName = override[&quot;element&quot;] ?
                        override[&quot;element&quot;].toLowerCase() :
                        style.element;
                    attrs = override[&quot;attributes&quot;];
                    styles = override[&quot;styles&quot;];
                }

                // We can have more than one override definition for the same
                // element name, so we attempt to simply append information to
                // it if it already exists.
                overrideEl = overrides[ elementName ] ||
                    ( overrides[ elementName ] = {} );

                if (attrs) {
                    // The returning attributes list is an array, because we
                    // could have different override definitions for the same
                    // attribute name.
                    var overrideAttrs = ( overrideEl[&quot;attributes&quot;] =
                        overrideEl[&quot;attributes&quot;] || new Array() );
                    for (var attName in attrs) {
                        // Each item in the attributes array is also an array,
                        // where [0] is the attribute name and [1] is the
                        // override value.
                        overrideAttrs.push([ attName.toLowerCase(), attrs[ attName ] ]);
                    }
                }


                if (styles) {
                    // The returning attributes list is an array, because we
                    // could have different override definitions for the same
                    // attribute name.
                    var overrideStyles = ( overrideEl[&quot;styles&quot;] =
                        overrideEl[&quot;styles&quot;] || new Array() );
                    for (var styleName in styles) {
                        // Each item in the styles array is also an array,
                        // where [0] is the style name and [1] is the
                        // override value.
                        overrideStyles.push([ styleName.toLowerCase(),
                            styles[ styleName ] ]);
                    }
                }
            }
        }
        return overrides;
    }

    // Removes a style from an element itself, don't care about its subtree.
    function removeFromElement(style, element) {
        var def = style._.definition,
            overrides = getOverrides(style),
            attributes = S.merge(def[&quot;attributes&quot;],
                (overrides[ element.nodeName()] || overrides[&quot;*&quot;] || {})[&quot;attributes&quot;]),
            styles = S.merge(def[&quot;styles&quot;],
                (overrides[ element.nodeName()] || overrides[&quot;*&quot;] || {})[&quot;styles&quot;]),
        // If the style is only about the element itself, we have to remove the element.
            removeEmpty = S.isEmptyObject(attributes) &amp;&amp;
                S.isEmptyObject(styles);

        // Remove definition attributes/style from the element.
        for (var attName in attributes) {

            // The 'class' element value must match (#1318).
            if (( attName == 'class' || style._.definition[&quot;fullMatch&quot;] )
                &amp;&amp; element.attr(attName) != normalizeProperty(attName,
                attributes[ attName ]))
                continue;
            removeEmpty = removeEmpty || !!element.hasAttr(attName);
            element.removeAttr(attName);

        }

        for (var styleName in styles) {

            // Full match style insist on having fully equivalence. (#5018)
            if (style._.definition[&quot;fullMatch&quot;]
                &amp;&amp; element.style(styleName)
                != normalizeProperty(styleName, styles[ styleName ], TRUE))
                continue;

            removeEmpty = removeEmpty || !!element.style(styleName);
            //设置空即为：清除样式
            element.style(styleName, &quot;&quot;);

        }

        //removeEmpty &amp;&amp;
        //始终检查
        removeNoAttribsElement(element);
    }

    function normalizeProperty(name, value, isStyle) {
        var temp = new Node('&lt;span&gt;');
        temp [ isStyle ? 'style' : 'attr' ](name, value);
        return temp[ isStyle ? 'style' : 'attr' ](name);
    }

    // Removes a style from inside an element.
    function removeFromInsideElement(style, element) {
        var //def = style._.definition,
        //attribs = def.attributes,
        //styles = def.styles,
            overrides = getOverrides(style),
            innerElements = element.all(style[&quot;element&quot;]);

        for (var i = innerElements.length; --i &gt;= 0;) {
            removeFromElement(style, new Node(innerElements[i]));
        }

        // Now remove any other element with different name that is
        // defined to be overridden.
        for (var overrideElement in overrides) {

            if (overrideElement != style[&quot;element&quot;]) {
                innerElements = element.all(overrideElement);
                for (i = innerElements.length - 1; i &gt;= 0; i--) {
                    var innerElement = new Node(innerElements[i]);
                    removeOverrides(innerElement,
                        overrides[ overrideElement ]);
                }
            }

        }

    }

    /*
       Remove overriding styles/attributes from the specific element.
       Note: Remove the element if no attributes remain.
     */
    function removeOverrides(element, overrides) {
        var i, attributes = overrides &amp;&amp; overrides[&quot;attributes&quot;];

        if (attributes) {
            for (i = 0; i &lt; attributes.length; i++) {
                var attName = attributes[i][0], actualAttrValue;

                if (( actualAttrValue = element.attr(attName) )) {
                    var attValue = attributes[i][1];

                    // Remove the attribute if:
                    //    - The override definition value is NULL ;
                    //    - The override definition valie is a string that
                    //      matches the attribute value exactly.
                    //    - The override definition value is a regex that
                    //      has matches in the attribute value.
                    if (attValue === NULL ||
                        ( attValue.test &amp;&amp; attValue.test(actualAttrValue) ) ||
                        ( typeof attValue == 'string' &amp;&amp; actualAttrValue == attValue ))
                        element[0].removeAttribute(attName);
                }
            }
        }

        var styles = overrides &amp;&amp; overrides[&quot;styles&quot;];

        if (styles) {
            for (i = 0; i &lt; styles.length; i++) {
                var styleName = styles[i][0], actualStyleValue;

                if (( actualStyleValue = element.css(styleName) )) {
                    var styleValue = styles[i][1];
                    if (styleValue === NULL ||
                        //styleValue === &quot;inherit&quot; ||
                        ( styleValue.test &amp;&amp; styleValue.test(actualAttrValue) ) ||
                        ( typeof styleValue == 'string' &amp;&amp; actualStyleValue == styleValue ))
                        element.css(styleName, &quot;&quot;);
                }
            }
        }

        removeNoAttribsElement(element);
    }

    // If the element has no more attributes, remove it.
    function removeNoAttribsElement(element) {
        // If no more attributes remained in the element, remove it,
        // leaving its children.
        if (!element._4e_hasAttributes()) {
            // Removing elements may open points where merging is possible,
            // so let's cache the first and last nodes for later checking.
            var firstChild = element[0].firstChild,
                lastChild = element[0].lastChild;

            element._4e_remove(TRUE);

            if (firstChild) {
                // Check the cached nodes for merging.
                firstChild.nodeType == Dom.NodeType.ELEMENT_NODE &amp;&amp;
                Dom._4e_mergeSiblings(firstChild);

                if (lastChild &amp;&amp; firstChild != lastChild
                    &amp;&amp; lastChild.nodeType == Dom.NodeType.ELEMENT_NODE)
                    Dom._4e_mergeSiblings(lastChild);
            }
        }
    }

    Editor.Style = KEStyle;

    return KEStyle;
}, {
    requires: ['./base', './range', './selection', './domIterator', './elementPath', 'node']
});
<span id='global-property-'>/**
</span> * @ignore
 * TODO yiminghe@gmail.com : 重构 Refer
 *  - http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html
 */</pre>
</body>
</html>
